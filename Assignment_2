library(tidyverse)
library(glmnet)
load("prostate.RData")

#### Ridge regression ####
indep <- prostate %>%               # Extracting covariate names
  select(-c(lpsa, group)) %>%
  colnames()
dep <- "lpsa"

ridge <- function(data, dep, indep, lambda){  # Estimating betas
  int <- matrix(rep(1, nrow(data)), ncol = 1) # Intercept ones
  reg <- as.matrix(data %>%           # Indepentent vars
                    select(indep)) 
  X <- cbind(int, reg)                # Regressor matrix
  y <- as.matrix(data %>%             # Dependent variable
                   select(dep))
  lambda <- lambda
  Id <- diag(ncol(X))                 # Identity matrix
  beta_ridge <- solve(crossprod(X,X) + lambda*Id) %*% t(X) %*% y
  beta_ridge = as.vector(beta_ridge)  # Vectorizing output
  return(beta_ridge)
}

beta_hat <- ridge(prostate, dep,    # Saving betas
                  indep , 10)
beta_hat
class(beta_hat)                       # Testing class

pred <- function(data, indep, beta_hat){      # Estimating yhats
  int <- matrix(rep(1, nrow(data)), ncol = 1) # Intercept ones
  reg <- as.matrix(data %>%           # Indepentent vars
                     select(indep)) 
  X <- cbind(int, reg)                # Regressor matrix
  B <- as.matrix(beta_hat)            # Betas as matrix
  preds <- X %*% B                    # Predicted values
  preds <- as.vector(preds)
  return(preds)
}

pred_vals <- pred(prostate, indep, beta_hat)
pred_vals <- tibble(Predicted = pred_vals)
pred_vals

cv <- function(data, dep, indep, lambda){
  n <- length(unique(data$group))    # Number of groups
  mse <- numeric(n)                  # Preallocation
  for (i in 1:n){                    # One per group
    X <- data %>%                    # Filtering groups
      filter(group != i)
    X_pred <- data %>%
      filter(group == i)             # Data for prediction
    Y <- as.vector(X_pred$lpsa)       # Values to predict
    betas <- ridge(X, dep = dep,     # Dependent var
                   indep = indep,    # Independent vars
                   lambda = lambda)
    preds <- pred(X_pred, indep, 
                  betas)             # Using estimated betas
    mse[i] <- mean((Y - preds)^2)    # Computing MSE
    
  }
  mse <- as.vector(mean(mse))        # Mean of MSE:s
  return(mse)
}


cv(prostate, dep, indep, 10)


l <- seq(0, 50, length.out = 50)
mse <- numeric(length(l))
for(i in 1:length(l)){
  mse[i] <- cv(prostate, "lpsa", indep, l[i])

}
mse

mse %>%
  enframe() %>%
  ggplot() +
  geom_line(aes(x = name, y = value, color = "red")) +
  labs(x = expression(lambda),
       y = "MSE",
       title = expression(MSE~plotted~against~lambda)) +
  theme_classic() +
  theme(plot.title = element_text(face = "bold",              
                                  hjust = 0.5, size = 15),
        axis.title.x = element_text(size = 15),
        panel.grid.major = element_line(color = "gray90")
        ) + 
  guides(color = FALSE)
